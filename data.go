// Code generated by go-bindata.
// sources:
// public.pem
// private.pem
// ui/404.html
// ui/451.html
// ui/index.html
// ui/assets/.DS_Store
// ui/assets/bin/.DS_Store
// ui/assets/bin/custom.js
// ui/assets/bin/dashboard.bundle.js
// ui/assets/bin/service-worker.js
// ui/assets/bin/website.bundle.js
// ui/assets/css/.DS_Store
// ui/assets/css/tachyons+loadingio.css
// ui/assets/img/.DS_Store
// ui/assets/img/appIcon.png
// ui/assets/img/appimage.png
// ui/assets/img/applestore.png
// ui/assets/img/default.jpg
// ui/assets/img/googlestore.png
// ui/assets/img/logo.png
// ui/assets/manifest.json
// DO NOT EDIT!

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// bindataRead reads the given file from disk. It returns an error on failure.
func bindataRead(path, name string) ([]byte, error) {
	buf, err := ioutil.ReadFile(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset %s at %s: %v", name, path, err)
	}
	return buf, err
}

type asset struct {
	bytes []byte
	info  os.FileInfo
}

// publicPem reads file data from disk. It returns an error on failure.
func publicPem() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/public.pem"
	name := "public.pem"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// privatePem reads file data from disk. It returns an error on failure.
func privatePem() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/private.pem"
	name := "private.pem"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// ui404Html reads file data from disk. It returns an error on failure.
func ui404Html() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/404.html"
	name := "ui/404.html"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// ui451Html reads file data from disk. It returns an error on failure.
func ui451Html() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/451.html"
	name := "ui/451.html"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiIndexHtml reads file data from disk. It returns an error on failure.
func uiIndexHtml() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/index.html"
	name := "ui/index.html"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsDs_store reads file data from disk. It returns an error on failure.
func uiAssetsDs_store() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/.DS_Store"
	name := "ui/assets/.DS_Store"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsBinDs_store reads file data from disk. It returns an error on failure.
func uiAssetsBinDs_store() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/bin/.DS_Store"
	name := "ui/assets/bin/.DS_Store"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsBinCustomJs reads file data from disk. It returns an error on failure.
func uiAssetsBinCustomJs() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/bin/custom.js"
	name := "ui/assets/bin/custom.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsBinDashboardBundleJs reads file data from disk. It returns an error on failure.
func uiAssetsBinDashboardBundleJs() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/bin/dashboard.bundle.js"
	name := "ui/assets/bin/dashboard.bundle.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsBinServiceWorkerJs reads file data from disk. It returns an error on failure.
func uiAssetsBinServiceWorkerJs() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/bin/service-worker.js"
	name := "ui/assets/bin/service-worker.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsBinWebsiteBundleJs reads file data from disk. It returns an error on failure.
func uiAssetsBinWebsiteBundleJs() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/bin/website.bundle.js"
	name := "ui/assets/bin/website.bundle.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsCssDs_store reads file data from disk. It returns an error on failure.
func uiAssetsCssDs_store() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/css/.DS_Store"
	name := "ui/assets/css/.DS_Store"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsCssTachyonsLoadingioCss reads file data from disk. It returns an error on failure.
func uiAssetsCssTachyonsLoadingioCss() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/css/tachyons+loadingio.css"
	name := "ui/assets/css/tachyons+loadingio.css"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsImgDs_store reads file data from disk. It returns an error on failure.
func uiAssetsImgDs_store() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/img/.DS_Store"
	name := "ui/assets/img/.DS_Store"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsImgAppiconPng reads file data from disk. It returns an error on failure.
func uiAssetsImgAppiconPng() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/img/appIcon.png"
	name := "ui/assets/img/appIcon.png"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsImgAppimagePng reads file data from disk. It returns an error on failure.
func uiAssetsImgAppimagePng() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/img/appimage.png"
	name := "ui/assets/img/appimage.png"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsImgApplestorePng reads file data from disk. It returns an error on failure.
func uiAssetsImgApplestorePng() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/img/applestore.png"
	name := "ui/assets/img/applestore.png"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsImgDefaultJpg reads file data from disk. It returns an error on failure.
func uiAssetsImgDefaultJpg() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/img/default.jpg"
	name := "ui/assets/img/default.jpg"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsImgGooglestorePng reads file data from disk. It returns an error on failure.
func uiAssetsImgGooglestorePng() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/img/googlestore.png"
	name := "ui/assets/img/googlestore.png"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsImgLogoPng reads file data from disk. It returns an error on failure.
func uiAssetsImgLogoPng() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/img/logo.png"
	name := "ui/assets/img/logo.png"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// uiAssetsManifestJson reads file data from disk. It returns an error on failure.
func uiAssetsManifestJson() (*asset, error) {
	path := "/Codebase/GolangProjects/src/passworddelay/ui/assets/manifest.json"
	name := "ui/assets/manifest.json"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"public.pem": publicPem,
	"private.pem": privatePem,
	"ui/404.html": ui404Html,
	"ui/451.html": ui451Html,
	"ui/index.html": uiIndexHtml,
	"ui/assets/.DS_Store": uiAssetsDs_store,
	"ui/assets/bin/.DS_Store": uiAssetsBinDs_store,
	"ui/assets/bin/custom.js": uiAssetsBinCustomJs,
	"ui/assets/bin/dashboard.bundle.js": uiAssetsBinDashboardBundleJs,
	"ui/assets/bin/service-worker.js": uiAssetsBinServiceWorkerJs,
	"ui/assets/bin/website.bundle.js": uiAssetsBinWebsiteBundleJs,
	"ui/assets/css/.DS_Store": uiAssetsCssDs_store,
	"ui/assets/css/tachyons+loadingio.css": uiAssetsCssTachyonsLoadingioCss,
	"ui/assets/img/.DS_Store": uiAssetsImgDs_store,
	"ui/assets/img/appIcon.png": uiAssetsImgAppiconPng,
	"ui/assets/img/appimage.png": uiAssetsImgAppimagePng,
	"ui/assets/img/applestore.png": uiAssetsImgApplestorePng,
	"ui/assets/img/default.jpg": uiAssetsImgDefaultJpg,
	"ui/assets/img/googlestore.png": uiAssetsImgGooglestorePng,
	"ui/assets/img/logo.png": uiAssetsImgLogoPng,
	"ui/assets/manifest.json": uiAssetsManifestJson,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}
var _bintree = &bintree{nil, map[string]*bintree{
	"private.pem": &bintree{privatePem, map[string]*bintree{}},
	"public.pem": &bintree{publicPem, map[string]*bintree{}},
	"ui": &bintree{nil, map[string]*bintree{
		"404.html": &bintree{ui404Html, map[string]*bintree{}},
		"451.html": &bintree{ui451Html, map[string]*bintree{}},
		"assets": &bintree{nil, map[string]*bintree{
			".DS_Store": &bintree{uiAssetsDs_store, map[string]*bintree{}},
			"bin": &bintree{nil, map[string]*bintree{
				".DS_Store": &bintree{uiAssetsBinDs_store, map[string]*bintree{}},
				"custom.js": &bintree{uiAssetsBinCustomJs, map[string]*bintree{}},
				"dashboard.bundle.js": &bintree{uiAssetsBinDashboardBundleJs, map[string]*bintree{}},
				"service-worker.js": &bintree{uiAssetsBinServiceWorkerJs, map[string]*bintree{}},
				"website.bundle.js": &bintree{uiAssetsBinWebsiteBundleJs, map[string]*bintree{}},
			}},
			"css": &bintree{nil, map[string]*bintree{
				".DS_Store": &bintree{uiAssetsCssDs_store, map[string]*bintree{}},
				"tachyons+loadingio.css": &bintree{uiAssetsCssTachyonsLoadingioCss, map[string]*bintree{}},
			}},
			"img": &bintree{nil, map[string]*bintree{
				".DS_Store": &bintree{uiAssetsImgDs_store, map[string]*bintree{}},
				"appIcon.png": &bintree{uiAssetsImgAppiconPng, map[string]*bintree{}},
				"appimage.png": &bintree{uiAssetsImgAppimagePng, map[string]*bintree{}},
				"applestore.png": &bintree{uiAssetsImgApplestorePng, map[string]*bintree{}},
				"default.jpg": &bintree{uiAssetsImgDefaultJpg, map[string]*bintree{}},
				"googlestore.png": &bintree{uiAssetsImgGooglestorePng, map[string]*bintree{}},
				"logo.png": &bintree{uiAssetsImgLogoPng, map[string]*bintree{}},
			}},
			"manifest.json": &bintree{uiAssetsManifestJson, map[string]*bintree{}},
		}},
		"index.html": &bintree{uiIndexHtml, map[string]*bintree{}},
	}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

